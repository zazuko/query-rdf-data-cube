import { namedNode, variable } from "@rdfjs/data-model";
import namespace from "@rdfjs/namespace";
import { Literal, NamedNode, Term } from "rdf-js";
import { Generator as SparqlGenerator } from "sparqljs";
import { Attribute, Component, Dimension, Measure } from "./components";
import { BaseOptions } from "./entrypoint";
import { Query, QueryOptions } from "./query";
import { generateLangCoalesce, generateLangOptionals, labelPredicate, literalFromJSON } from "./queryutils";
import { literalToJSON, prefixes, SerializedLiteral } from "./queryutils";
import { SparqlFetcher } from "./sparqlfetcher";
import { BlockPattern, SelectQuery } from "./sparqljs";

/**
 * @ignore
 */
type ComponentsCache = {
  attributes: Map<string, Attribute>,
  dimensions: Map<string, Dimension>,
  measures: Map<string, Measure>,
};
/**
 * @ignore
 */
type GroupedComponents = { kind: Term, iri: Term, label: Label, extraMetadata?: object };

type SerializedDataCube = {
  endpoint: string,
  iri: string,
  graphIri: string,
  label: Label,
  languages: string[],
  extraMetadata: { [key: string]: SerializedLiteral },
  components: {
    dimensions: string[],
    measures: string[],
    attributes: string[],
  },
};

/**
 * Represents an RDF
 * [language-tagged string](https://www.w3.org/TR/rdf11-concepts/#dfn-language-tagged-string).
 */
export interface Label {
  /**
   * String value
   */
  value: string;
  /**
   * Language tag such as "en", "fr", "de".
   * See [Tags for Identifying Languages](https://tools.ietf.org/html/bcp47).
   */
  language: string;
}

export interface DataCubeOptions extends BaseOptions {
  iri: NamedNode;
  graphIri: NamedNode;
  label?: Label;
  extraMetadata?: Map<string, any>;
}

const cube = namespace("http://purl.org/linked-data/cube#");

/**
 * @class DataCube
 */
export class DataCube {
  /**
   * Deserializes a [[DataCube]] from JSON generated by [[toJSON]]
   */
  public static fromJSON(json: string): DataCube {
    const obj: SerializedDataCube = JSON.parse(json);
    const dataCube = new DataCube(obj.endpoint, {
      iri: namedNode(obj.iri),
      graphIri: namedNode(obj.graphIri),
      label: obj.label,
      languages: obj.languages,
      extraMetadata: Object.entries(obj.extraMetadata || {}).reduce((acc, [key, serializedLit]) => {
        acc.set(key, literalFromJSON(serializedLit));
        return acc;
      }, new Map()),
    });
    ["dimensions", "measures", "attributes"].forEach((componentTypes) => {
      dataCube.cachedComponents[componentTypes] = obj.components[componentTypes]
        .map((componentObject: object) => Component.fromJSON(JSON.stringify(componentObject)))
        .reduce((cache: Map<string, Component>, component: Component) => {
          cache.set(component.iri.value, component);
          return cache;
        }, new Map());
    });
    return dataCube;
  }

  public label: Label;
  public iri: string;
  public endpoint: string;
  public graphIri?: string;
  public extraMetadata: Map<string, Literal>;
  private languages: string[];
  public fetcher: SparqlFetcher;
  private componentsLoaded: boolean = false;
  private cachedComponents: ComponentsCache;

   /**
    * @param endpoint SPARQL endpoint where the DataCube lives.
    * @param options Additional info about the DataCube.
    * @param options.iri The IRI of the DataCube.
    * @param options.graphIri The IRI of the graph from which the data will be fetched.
    * @param options.label (Optional) A label for the DataCube in the following form:
    * `{ value: "Something", language: "en" }`
    * @param options.languages Languages in which to get the label, by priority, e.g. `["de", "en"]`.
    */
  constructor(
    endpoint: string,
    options: DataCubeOptions,
    fetcher?: SparqlFetcher
  ) {
    const { iri, label, graphIri, extraMetadata } = options;
    this.fetcher = fetcher || new SparqlFetcher(endpoint, options.fetcher);
    this.endpoint = endpoint;
    this.iri = iri.value;
    this.graphIri = graphIri.value;
    this.label = label;
    this.languages = options.languages || [];
    this.extraMetadata = extraMetadata;
    this.cachedComponents = {
      dimensions: new Map(),
      measures: new Map(),
      attributes: new Map(),
    };
  }

  /**
   * Serializes a [[DataCube]] to JSON in a way that makes it deserializable
   * by calling [[fromJSON]]
   */
  public toJSON(): string {
    const dimensions = Array.from(this.cachedComponents.dimensions.values())
      .map((component) => JSON.parse(component.toJSON()));
    const measures = Array.from(this.cachedComponents.measures.values())
      .map((component) => JSON.parse(component.toJSON()));
    const attributes = Array.from(this.cachedComponents.attributes.values())
      .map((component) => JSON.parse(component.toJSON()));
    const extraMetadata = Array.from(this.extraMetadata.entries())
      .reduce((acc, [key, lit]) => {
        if (lit) {
          acc[key] = literalToJSON(lit);
        }
        return acc;
      }, {});
    const obj: SerializedDataCube = {
      endpoint: this.endpoint,
      iri: this.iri,
      graphIri: this.graphIri,
      label: this.label,
      languages: this.languages,
      extraMetadata,
      components: {
        dimensions,
        measures,
        attributes,
      },
    };
    return JSON.stringify(obj);
  }

  /**
   * Fetch all [[Attribute]]s from the [[DataCube]].
   */
  public async attributes(): Promise<Attribute[]> {
    if (!this.cachedComponents.attributes.size) {
      await this.components();
    }
    return Array.from(this.cachedComponents.attributes.values());
  }

  /**
   * Fetch all [[Dimension]]s from the [[DataCube]].
   */
  public async dimensions(): Promise<Dimension[]> {
    if (!this.cachedComponents.dimensions.size) {
      await this.components();
    }
    return Array.from(this.cachedComponents.dimensions.values());
  }

  /**
   * Fetch all [[Measure]]s from the [[DataCube]].
   */
  public async measures(): Promise<Measure[]> {
    if (!this.cachedComponents.measures.size) {
      await this.components();
    }
    return Array.from(this.cachedComponents.measures.values());
  }

  /**
   * Start a new query on the DataCube.
   */
  public query(opts: QueryOptions = {}): Query {
    if (!opts.languages) {
      opts.languages = this.languages;
    }
    return new Query(this, opts);
  }

  /**
   * Retrieve all the possible values several [[Component]] ([[Dimension]], [[Measure]], [[Attribute]]) can have.
   * Similar to [[DataCube.componentValues]] but for several components.
   * See also [[Query.componentValues]] and the examples folder.
   * ```js
   * const values = await dataCube.componentsValues([timeDimension, sizeDimension, populationMeasure]);
   * ```
   * @param {Component[]} components
   * @returns {Promise<Array<{label: Literal, value: NamedNode | Literal}>>}
   */
  public async componentsValues(components: Component[]):
    Promise<WeakMap<Component, Array<{label: Literal, value: NamedNode | Literal}>>> {
    const valueBinding = variable("value");
    const labelBinding = variable("label");
    const observation = variable("observation");
    const componentBinding = variable("component");

    const componentIRIs = components.map((comp) => comp.iri);

    const query: SelectQuery = {
      prefixes,
      queryType: "SELECT",
      variables: [componentBinding, valueBinding, labelBinding],
      distinct: true,
      from: { default: [namedNode(this.graphIri)], named: [] },
      where: [
        {
          type: "bgp",
          triples: [
            {
              subject: observation,
              predicate: namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"),
              object: cube("Observation"),
            },
            {
              subject: observation,
              predicate: componentBinding,
              object: valueBinding,
            },
            {
              subject: observation,
              predicate: cube("dataSet"),
              object: namedNode(this.iri),
            },
          ],
        },
        {
          type: "filter",
          expression: {
            type: "operation",
            operator: "in",
            args: [
              componentBinding,
              componentIRIs,
            ],
          },
        },
        ...generateLangOptionals(valueBinding, labelBinding, labelPredicate, this.languages),
        generateLangCoalesce(labelBinding, this.languages),
      ],
      type: "query",
    };

    const generator = new SparqlGenerator({ allPrefixes: true });
    const sparql = generator.stringify(query);
    const rawResult: Array<{component: NamedNode, label: Literal, value: NamedNode | Literal}>
      = await this.fetcher.select(sparql);
    const resultMap = new WeakMap();
    components.forEach((comp) => {
      const values = rawResult.reduce((acc, row) => {
        if (row.component.equals(comp.iri)) {
          acc.push({ label: row.label, value: row.value });
        }
        return acc;
      }, []);
      resultMap.set(comp, values);
    });
    return resultMap;
  }

  /**
   * Retrieve all the possible values a [[Component]] ([[Dimension]], [[Measure]], [[Attribute]]) can have.
   * Similar to [[DataCube.componentsValues]] but for a single Component.
   * See also [[Query.componentValues]] and the examples folder.
   * ```js
   * const values = await dataCube.componentValues(sizeClasses);
   * ```
   * @param {Component} component
   * @returns {Promise<Array<{label: Literal, value: NamedNode | Literal}>>}
   */
  public async componentValues(component: Component): Promise<Array<{label: Literal, value: NamedNode | Literal}>> {
    if (!component || !component.componentType) {
      throw new Error(`dataCube#componentValues expects valid component, got ${component} instead`);
    }
    const binding = variable("value");
    const labelBinding = variable("label");
    const observation = variable("observation");

    const query: SelectQuery = {
      prefixes,
      queryType: "SELECT",
      variables: [binding, labelBinding],
      distinct: true,
      from: { default: [namedNode(this.graphIri)], named: [] },
      where: [
        {
          type: "bgp",
          triples: [
            {
              subject: observation,
              predicate: namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"),
              object: cube("Observation"),
            },
            {
              subject: observation,
              predicate: component.iri,
              object: binding,
            },
            {
              subject: observation,
              predicate: cube("dataSet"),
              object: namedNode(this.iri),
            },
          ],
        },
        ...generateLangOptionals(binding, labelBinding, labelPredicate, this.languages),
        generateLangCoalesce(labelBinding, this.languages),
      ],
      type: "query",
    };

    const generator = new SparqlGenerator({ allPrefixes: true });
    const sparql = generator.stringify(query);
    return await this.fetcher.select(sparql);
  }

  /**
   * Retrieve the maximal and minimal values of several [[Component]] ([[Dimension]], [[Measure]], [[Attribute]]).
   * Similar to [[DataCube.componentMinMax]] but for several Components.
   * See also [[Query.componentMinMax]] and the examples folder.
   *
   * @param {Component[]} components
   * @returns Promise<WeakMap<Component, {min: Literal|null, max: Literal|null}>>
   */
  public async componentsMinMax(components: Component[]):
    Promise<WeakMap<Component, {min: Literal|null, max: Literal|null}>> {
    const valueBinding = variable("value");
    const observation = variable("observation");
    const componentBinding = variable("component");

    const componentIRIs = components.map((comp) => comp.iri);

    const query: SelectQuery = {
      prefixes,
      queryType: "SELECT",
      variables: [
        componentBinding,
        {
          expression: {
            expression: valueBinding,
            type: "aggregate",
            aggregation: "min",
            distinct: false,
          },
          variable: variable("min"),
        },
        {
          expression: {
            expression: valueBinding,
            type: "aggregate",
            aggregation: "max",
            distinct: false,
          },
          variable: variable("max"),
        },
      ],
      from: { default: [namedNode(this.graphIri)], named: [] },
      where: [
        {
          type: "bgp",
          triples: [
            {
              subject: observation,
              predicate: namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"),
              object: cube("Observation"),
            },
            {
              subject: observation,
              predicate: componentBinding,
              object: valueBinding,
            },
            {
              subject: observation,
              predicate: cube("dataSet"),
              object: namedNode(this.iri),
            },
          ],
        },
        {
          type: "filter",
          expression: {
            type: "operation",
            operator: "isliteral",
            args: [valueBinding],
          },
        },
        {
          type: "filter",
          expression: {
            type: "operation",
            operator: "in",
            args: [
              componentBinding,
              componentIRIs,
            ],
          },
        },
      ],
      group: [{ expression: componentBinding }],
      type: "query",
    };

    const generator = new SparqlGenerator({ allPrefixes: true });
    const sparql = generator.stringify(query);
    const rawResult: Array<{component: NamedNode, min: Literal, max: Literal}>
      = await this.fetcher.select(sparql);
    const resultMap = new WeakMap();
    components.forEach((comp) => {
      const values = rawResult.reduce((acc, row) => {
        if (!row.component) {
          return acc;
        }
        if (row.component.equals(comp.iri)) {
          return { min: row.min, max: row.max };
        }
        if (acc) {
          return acc;
        }
        return { min: null, max: null };
      }, null);
      resultMap.set(comp, values);
    });
    return resultMap;
  }

  /**
   * Retrieve the maximal and minimal values of a [[Component]] ([[Dimension]], [[Measure]], [[Attribute]]).
   * Similar to [[DataCube.componentsMinMax]] but for a single Component.
   * See also [[Query.componentMinMax]] and the examples folder.
   *
   * @param {Component} component
   * @returns Promise<{min: Literal|null, max: Literal|null}>
   */
  public async componentMinMax(component: Component): Promise<{min: Literal|null, max: Literal|null}> {
    if (!component || !component.componentType) {
      throw new Error(`dataCube#componentMinMax expects valid component, got ${component} instead`);
    }
    const binding = variable("value");
    const observation = variable("observation");

    const query: SelectQuery = {
      prefixes,
      queryType: "SELECT",
      variables: [
        {
          expression: {
            expression: binding,
            type: "aggregate",
            aggregation: "min",
            distinct: false,
          },
          variable: variable("min"),
        },
        {
          expression: {
            expression: binding,
            type: "aggregate",
            aggregation: "max",
            distinct: false,
          },
          variable: variable("max"),
        },
      ],
      from: { default: [namedNode(this.graphIri)], named: [] },
      where: [
        {
          type: "bgp",
          triples: [
            {
              subject: observation,
              predicate: namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"),
              object: cube("Observation"),
            },
            {
              subject: observation,
              predicate: component.iri,
              object: binding,
            },
            {
              subject: observation,
              predicate: cube("dataSet"),
              object: namedNode(this.iri),
            },
          ],
        },
        {
          type: "filter",
          expression: {
            type: "operation",
            operator: "isliteral",
            args: [binding],
          },
        },
      ],
      type: "query",
    };

    const generator = new SparqlGenerator({ allPrefixes: true });
    const sparql = generator.stringify(query);
    const results = await this.fetcher.select(sparql);
    if (results.length) {
      return results[0];
    }
    return { min: null, max: null };
  }

  private async components() {
    if (this.componentsLoaded) {
      return;
    }

    const binding = variable("iri");
    const labelBinding = variable("label");
    const scaleOfMeasureBinding = variable("scaleOfMeasure");
    const scaleOfMeasureOptional: BlockPattern = {
      type: "optional",
      patterns: [
        {
          type: "bgp",
          triples: [
            {
              subject: binding,
              predicate: namedNode("http://ns.bergnet.org/cube/scale/scaleOfMeasure"),
              object: scaleOfMeasureBinding,
            },
          ],
        },
      ],
    };

    const query: SelectQuery = {
      prefixes,
      queryType: "SELECT",
      variables: [
        binding,
        variable("kind"),
        labelBinding,
        scaleOfMeasureBinding,
      ],
      from: { default: [namedNode(this.graphIri)], named: [] },
      where: [
        {
          type: "bgp",
          triples: [
            {
              subject: namedNode(this.iri),
              predicate: namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"),
              object: cube("DataSet"),
            },
            {
              subject: namedNode(this.iri),
              predicate: {
                type: "path",
                pathType: "/",
                items: [
                  cube("structure"),
                  cube("component"),
                ],
              },
              object: variable("componentSpec"),
            },
            {
              subject: variable("componentSpec"),
              predicate: variable("kind"),
              object: binding,
            },
          ],
        },
        {
          type: "filter",
          expression: {
            type: "operation",
            operator: "in",
            args: [
              variable("kind"),
              [
                cube("attribute"),
                cube("dimension"),
                cube("measure"),
              ],
            ],
          },
        },
        scaleOfMeasureOptional,
        ...generateLangOptionals(binding, labelBinding, labelPredicate, this.languages),
        generateLangCoalesce(labelBinding, this.languages),
      ],
      type: "query",
    };

    const generator = new SparqlGenerator({ allPrefixes: true });
    const sparql = generator.stringify(query);

    const components = await this.fetcher.select(sparql);
    const groupedComponents: GroupedComponents[] = components.map(({ kind, label, iri, scaleOfMeasure }) => {
      return {
        kind,
        label: {
          value: label.value,
          language: label.language,
        },
        iri,
        extraMetadata: { scaleOfMeasure },
      };
    });

    this.cachedComponents = groupedComponents
      .reduce((componentsProp: ComponentsCache, { kind, label, iri, extraMetadata }) => {
        switch (kind.value) {
          case "http://purl.org/linked-data/cube#attribute":
            if (!componentsProp.attributes.has(iri.value)) {
              componentsProp.attributes.set(iri.value, new Attribute({ label, iri, extraMetadata }));
            }
            break;
          case "http://purl.org/linked-data/cube#dimension":
            if (!componentsProp.dimensions.has(iri.value)) {
              componentsProp.dimensions.set(iri.value, new Dimension({ label, iri, extraMetadata }));
            }
            break;
          case "http://purl.org/linked-data/cube#measure":
            if (!componentsProp.measures.has(iri.value)) {
              componentsProp.measures.set(iri.value, new Measure({ label, iri, extraMetadata }));
            }
            break;
          default:
            throw new Error(`Unknown component kind ${kind.value}`);
        }
        return componentsProp;
      }, this.cachedComponents);

    this.componentsLoaded = true;
  }
}
